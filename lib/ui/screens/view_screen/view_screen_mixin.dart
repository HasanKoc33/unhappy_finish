import 'dart:async';import 'package:flutter/material.dart';import 'package:flutter_cube/flutter_cube.dart';import 'package:sleep/core/constants/app_assets.dart';import 'package:sleep/data/models/data.dart';import 'package:sleep/data/models/seans.dart';import 'package:sleep/data/services/cordinat_service.dart';import 'package:sleep/ui/screens/view_screen/view_screen.dart';/// ViewScreen mixin sınıfımixin ViewScreenMixin on State<ViewScreen> {  ValueNotifier<double> solBileklikProgres = ValueNotifier<double>(0);  int solIndex = 0;  ValueNotifier<double> sagBileklikProgres = ValueNotifier<double>(0);  int sagIndex = 0;  Timer? solTimer;  Timer? sagTimer;  late Seans solBileklik;  late Seans sagBileklik;  @override  void initState() {    super.initState();    solBileklik = widget.solBileklik?? Seans(datas: [], startTime: DateTime.now(), endTime: DateTime.now(),);    sagBileklik = widget.sagBileklik?? Seans(datas: [], startTime: DateTime.now(), endTime: DateTime.now(),);    startTimer();  }  @override  void dispose() {    solTimer?.cancel();    sagTimer?.cancel();    super.dispose();  }  void startTimer() {    solTimer = Timer.periodic(Duration(milliseconds: 100), (Timer t) => updateRigthData(t));    sagTimer = Timer.periodic(Duration(milliseconds: 100), (Timer t) => updateLeftData(t));  }  void updateRigthData(Timer t) {    sagBileklikProgres.value += 1 / (sagBileklik.datas.length);    if (sagIndex < sagBileklik.datas.length) {      updateRightHandRotation(sagBileklik.datas[sagIndex]);    }    sagIndex++;    if (sagBileklikProgres.value >= 1.0) {      sagBileklikProgres.value = 1.0;      if (sagIndex >= sagBileklik.datas.length) {        t.cancel();      }    }    sagBileklikProgres.notifyListeners();  }  void updateLeftData(Timer t) {    solBileklikProgres.value += 1 / (solBileklik.datas.length );    print('solIndex: ${solBileklikProgres.value}}');    if (solIndex < solBileklik.datas.length) {      updateLeftHandRotation(solBileklik.datas[solIndex]);    }    solIndex++;    if (solBileklikProgres.value >= 1.0) {      solBileklikProgres.value = 1;      if (solIndex >= solBileklik.datas.length) {        t.cancel();      }    }    solBileklikProgres.notifyListeners();  }  Object? leftHandObject;  Object? rightHandObject;  Object? humanObject;  Scene? scene;  Vector3 minHandPosition = Vector3(-2, -2, 0);  Vector3 maxHandPosition = Vector3(2, 2, 0);  double roll = 45.311893;  double pitch = 67.96784;  double yaw = -110.311893;  // vicudu ters çevir  Future<void> humanFrontRotation() async {    humanObject!.rotation.x = 0;    humanObject!.updateTransform();    scene?.update();    return;  }  Future<void> humanBackRotation() async {    humanObject!.rotation.x = 180;    humanObject!.updateTransform();    scene?.update();    return;  }  void sahne(Scene scene) {    final result = CordinatService.instance.calculateMinMaxCoordinates(solBileklik.datas.map((e) => Vector3(e.x, e.y, e.z)).toList());    print(result);    double scaleX = result['maxX']! - result['minX']!;    double scaleY = result['maxY']! - result['minY']!;    scene = scene;    leftHandObject = Object(      fileName: AppAsets.handL.value,      scale: Vector3(scaleX.abs() / 8, scaleY.abs() / 8, scaleY.abs() / 8),      position: Vector3(20, -25, 0),      rotation: Vector3(90, 180, 0),      lighting: true,    );    rightHandObject = Object(      fileName: AppAsets.handR.value,      scale: Vector3(scaleX.abs() / 10, scaleY.abs() / 10, scaleY.abs() / 10),      position: Vector3(10, -25, 0),      rotation: Vector3(0, 90, -90),      lighting: true,    );    humanObject = Object(      fileName: AppAsets.humanBody.value,      name: 'human',      isAsset: true,      position: Vector3(0, 0, 1),      rotation: Vector3(0, 195, 90),      scale: Vector3(scaleX.abs() * 2, scaleY.abs() * 2, scaleY.abs() * 2),      lighting: true,      backfaceCulling: true,    );    scene.world.add(humanObject!);    scene.world.add(leftHandObject!);    scene.world.add(rightHandObject!);    scene.camera.zoom = 1;    scene.camera.position.setValues(0, 0, -500);    scene.camera.target.setValues(scaleX.abs() / 2, 0, 0);    scene.light.position.setValues(20.0, 1.0, -50.0);  }  void updateLeftHandRotation(Data data) {    final roll = data.x;    final pitch = data.y;    final yaw = 10.0; //data.z;    print('pitch: $pitch, roll: $roll, yaw: $yaw');    leftHandObject!.position.setValues(pitch, roll, yaw);    leftHandObject!.updateTransform();    scene?.update();  }  void updateRightHandRotation(Data data) {    final roll = data.x;    final pitch = data.y;    final yaw = 10.0; //data.z;    rightHandObject!.position.setValues(pitch, roll, yaw);    rightHandObject!.updateTransform();    scene?.update();  }}